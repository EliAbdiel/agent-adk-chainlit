import chainlit as cl
from google.adk.agents import Agent
from google.adk.tools.agent_tool import AgentTool
from google.genai import types
from google.adk.runners import Runner
from google.adk.sessions.session import Session
from src.logs.logger import setup_logger
from src.config.common import GEMINI_MODEL

logger = setup_logger('Q&A AGENT')

qa_agent = Agent(
    model=GEMINI_MODEL,
    name="question_answer_agent",
    instruction="""You are an expert Document Assistant.
    
        Input structure:
        The user message will contain two parts:
        1. A specific **Question** or **Instruction**.
        2. The **Document Context**.

        Your task:
        Answer the user's question using **ONLY** the information provided in the Document Context.

        Guidelines:
        - **Synthesize**: If the user asks for an explanation, synthesize the 'Overview' and 'Key Details' sections naturally.
        - **Locate Data**: If the user asks for specific numbers, look immediately at the 'Data Points' or 'Findings' sections of the context.
        - **Problem Solve**: If the user asks for a specific problem to be solved in document context (e.g., math, code) and the context summary does not contain the answer, feel free to give the answer.
        - **Be Honest**: If the context summary does not contain the answer and the user don't asks for a specific problem to be solved, say: "The provided summary does not contain details about [topic]."
        - **No Preamble**: Do not say "Based on the summary...". Just give the answer.
        """,
    description="An agent that answers questions based on a pre-processed document summary.",
)

root_agent = Agent(
    model=GEMINI_MODEL,
    name='root_agent',
    instruction="""You are the main interface. 
    When the user provides a document context and a instruction, delegate it strictly to the 'question_answer_agent' tool.
    Make sure to pass the ENTIRE message (Question + Context) to the tool. Do not alter the content section.""",
    description="Coordination agent.",
    tools=[AgentTool(agent=qa_agent, skip_summarization=False)],
    sub_agents=[qa_agent]
)

# Agent Interaction
@cl.step(name="answer-user-question", type="tool", show_input=False)
async def call_qa_agent(runner: Runner, session: Session, user_id: str, query: str):
    """
    Call agent async and return final response
    
    Args:
        runner (Runner): The runner object
        session (Session): The session object
        query (str): The query to be sent to the agent
    
    Returns:
        str: The final response from the agent
    """
    try:
        content = types.Content(role='user', parts=[types.Part(text=query)])
        events = runner.run_async(user_id=user_id, session_id=session.id, new_message=content)
        
        final_text = ""
        # Iterate over events and get final response
        async for event in events:
            if hasattr(event, 'is_final_response') and event.is_final_response():
                if event.content and event.content.parts:
                    final_text = event.content.parts[0].text

        if final_text:
            logger.info(f"Search Response: {len(final_text)} chars")
            return final_text
        else:
            logger.warning("Agent finished but no text content was captured.")
            return "No response generated by the agent."
    except Exception as e:
        logger.error(f"Error: {e}")
        return None